#!/usr/bin/env ruby

require 'rubygems'
require 'thor'
require 'parallel'
require 'fileutils'
require 'pp'
require 'ruby-progressbar'

require './lib/helper'
require './lib/newick'
require './lib/multi_io'
require './lib/numeric'
require './lib/array'
require './lib/hash'
require './lib/bin_array'
require './lib/partition_array'


class Scheduling < Thor
  desc "generate", "schedule partitions on bins considering subtree repeats for one tree"
  option :tree_file, :required => true, :aliases => "-t",
         :desc => "Which tree should be used " \
                  "Example: '-t ./data/59/parsimony_trees/RAxML_result.T4.RUN.0' "
  option :partition_file, :required => true, :aliases => "-p",
         :desc => "Path to partition file " \
                  "Example: '-p ./data/59/59.partitions' "
  option :phylip_file, :required => true, :aliases => "-l",
         :desc => "Path to phylip file " \
                  "Example: '-l ./data/59/59.phy' "
  option :number_of_bins, :type => :numeric, :default => 3, :aliases => "-n",
         :desc => "Number of bins that the sites should be distributed to. " \
                  "Example: '-n 3' "
  option :optimize, :type => :numeric, :default => 20, :aliases => "-o",
         :desc => "Whether the result should be optimized after generation. Enter the number of repeats. " \
                  "Example: '-o 20' "
  option :number_of_processes, :type => :numeric, :default => 0, :aliases => "-P",
         :desc => "Parallel processing on 'x' cores. If 0 multithreading is disabled. [Not implemented]" \
                  "Example: '-P 2' "

  def generate

    # Initialize
    partition_file = options[:partition_file]
    phylip_file = options[:phylip_file]
    sample_root = 'midpoint'
    heuristic_options = ["greedy", "slice"]
    slice_options = ["sites", "operations"]
    sort_options = ["std", "lexi"]
    csv_output = []
    start_time = Time.now
    partitions_master = PartitionArray.from_file(partition_file)
    number_of_taxa, number_of_sites, phylip_data = read_phylip(phylip_file)
    graph_file_name = "graphs/#{phylip_file.scan(/(\w+)\//).join("-")} #{start_time.strftime "%Y-%m-%d %H-%M-%S"}"

    # Drop identical sites
    unless partition_file.include?("uniq")
      number_of_sites, partitions_master, phylip_data, partition_file, phylip_file =
          drop_unique_sites(partitions_master, phylip_data, partition_file, phylip_file, number_of_taxa)
    end

    puts "Program started at #{start_time}"
    puts "Using parameters: tree_file: #{options[:tree_file]}; " \
         "Partition file: #{partition_file}; Phylip File: #{phylip_file}; " \
         "Sample root nodes: #{sample_root}; " \
         "Number of taxa: #{number_of_taxa}; Number of sites: #{number_of_sites}; " \
         "Number of partitions: #{partitions_master.size}"


    # Get data
    tree_master = NewickTree.fromFile(options[:tree_file])
    tree_master = tree_master.add_dna_sequences(phylip_data)

    # Midpoint root
    tree_master = tree_master.set_edge_length.midpoint_root

    # Get partition sizes
    partitions_master.ml_operations!(tree_master)

    # Sort partitions by op_optimized
    partitions_master.sort!

    # Initialize bin list
    bins_master = BinArray.new(options[:number_of_bins])

    # Set bin target size for sliding window heuristic
    bins_master.set_bin_target_op_size!(partitions_master.op_optimized_size)
    bins_master.set_bin_target_sites_size!(partitions_master.total_sites)

    # Initial fill: Fill sorted partitions into bins as far as possible without breaking the partitions
    remaining_partitions_master = bins_master.initial_fill!(partitions_master)


    heuristic_options.each do |heuristic|

      # Get clean data
      bins = Marshal.load(Marshal.dump(bins_master))
      partitions = Marshal.load(Marshal.dump(partitions_master))
      remaining_partitions = Marshal.load(Marshal.dump(remaining_partitions_master))
      tree = Marshal.load(Marshal.dump(tree_master))

      if heuristic == "greedy"
        bins.greedy_initial_fill!(remaining_partitions, tree, "operations")
        bins.greedy_fill!(remaining_partitions)
        bins.ml_operations!(tree) # FIXME: Clean up functions then this command will be unnecessary

        csv_output << optimize_and_output(bins, heuristic, tree)

      elsif heuristic == "slice"

        sort_options.each do |sort|

          if sort == "lexi"

            # Get taxa sorted via tree traversal
            taxa = tree.taxa_with_nucleotides

            # Lexicographic sort sites per partition
            all_sites = taxa.values.map {|nucleotides| nucleotides.split('') }.transpose
            partitions.each do |partition|
              all_sites[(partition.sites.first .. partition.sites.last)] = all_sites[(partition.sites.first .. partition.sites.last)].sort
            end

            phylip_data = Hash[taxa.keys.zip(all_sites.transpose)]

            # Save in tree
            tree = tree.add_dna_sequences(phylip_data)

          end

          # Iterate over slicing options
          slice_options.each do |slice|

            # Get clean data
            bins = Marshal.load( Marshal.dump(bins_master))
            partitions = Marshal.load(Marshal.dump(partitions_master))
            remaining_partitions = Marshal.load(Marshal.dump(remaining_partitions_master))

            bins.slice_fill!(remaining_partitions, slice)
            bins.ml_operations!(tree)

            csv_output << optimize_and_output(bins, "#{slice}_#{sort}", tree)

          end

        end

      end

    end




    program_runtime = (Time.now - start_time).duration

    # Check if output folder exists
    output_directory = "./output_#{File.basename(__FILE__, ".rb")}"
    FileUtils.mkdir_p(output_directory)

    # Output results to CSV for R
    data_file = "#{output_directory}/#{start_time.strftime "%Y-%m-%d %H-%M-%S"} data.csv"
    puts "Writing data to #{data_file}"
    csv_output.flatten.array_of_hashes_to_csv_file(data_file)


    # Output parameters to CSV for R
    program_parameters_output = { number_of_bins: options[:number_of_bins], optimize_result: options[:optimize],
                                  phylip_file: phylip_file, sample_root: sample_root,
                                  number_of_processes: options[:number_of_processes],
                                  program_runtime: program_runtime, data_file: data_file,
                                  graph_file_name: graph_file_name,
    }

    parameter_file = "#{output_directory}/#{start_time.strftime "%Y-%m-%d %H-%M-%S"} parameters.csv"
    program_parameters_output.to_csv_file(parameter_file)
    puts "Program parameters written to #{parameter_file}"
    puts "Run corresponding R script '#{File.basename(__FILE__, ".rb")}.R' to generate graphs"

    puts "Program finished at #{Time.now}. Runtime: #{program_runtime}"


  end



end

Scheduling.start
